\documentclass[letterpaper,12pt]{article}
%
% Packages
%

%
% Metadata
%

\author{
Christian Babeux\\
Samuel Demers\\
J\'er\'emie Galarneau\\
David Laporte\\
Marianne Mailhot-Sarrasin
}
\title{Libarmisa developer's guide}
\pagestyle{headings}

%
% Document
%

\begin{document}

\maketitle
\tableofcontents

\newpage

\section{Introduction}
\label{sec:intro}

% - What is libarmisa
Libarmisa is a C++ library that implements the behavior of ARMv7
instructions as defined in the ARM Architecture Reference Manual
\cite{arm2009}. It uses function templates and adaptor structures to
make it as convenient as possible to include it within any kind of
application.

% - What kind of project would it be useful for
A library such as libarmisa would typically be useful in a simulation
or virtualization context. However, by providing an implementation
that is as close as possible to the specification, it can also fulfill
educational purposes.

% - Alternatives

% ARM Fast Models
Many standalone applications already implement the ARM instruction set
architecture. ARM Limited's own simulation software, Fast Models,
offers a complete software simulation environment and provides SystemC
and TLM models that can be integrated into complex hardware designs.

% Qemu
The QEMU open source machine emulator features ARM support. While it
was not designed with hardware system validation, it can run a great
variety of operating systems and applications compiled for ARM
processors.

% OVP
Imperas Software Limited's OVP platform offers a SystemC-based
simulation environment that includes, among others, an ARM Cortex-M
model.

% SWARM
The SWARM (SoftWare ARM) provides a cycle accurate simulation of an
ARM7 processor. It does not, however, support newer architectures.

% TRAP
TRAP (TRansaction level Automatic Processor generator) is a
processor simulator generator written in Python. It has already be
used to develop a functional ARM7TDMI processor model. It could
theoretically be used to develop instruction-accurate and
cycle-accurate models of newer ARM cores such as the Cortex-A
series. Since the models generated by TRAP are written in C++, most of
the instruction behavior could be handled by Libarmisa.

% TODO: cite

\section{Getting started on Linux}
\label{sec:getstarted}

This section explains how to build and install Libarmisa on
Linux. Building for other platforms would likely require changes to
the Makefile or the creation of IDE-specific project files.

% TODO: URLs for Boost, Doxygen, ...

Libarmisa requires the Boost library, as well as the Boost Test
library for unit tests. On Debian-based Linux distributions, these
packages can be installed using apt-get as superuser:
\begin{verbatim}
apt-get install libboost-dev libboost-test-dev
apt-get install doxygen
\end{verbatim}

To generate the PDF version of the API documentation as well as the
developer's guide, a \LaTeX distribution must also be installed:
\begin{verbatim}
apt-get install texlive-base
\end{verbatim}

Instructions for other Linux distributions may vary.

Once all dependencies have been installed, the library itself can be
built by using the ``make'' tool:
\begin{verbatim}
cd libarmisa
make
\end{verbatim}

This should build the static library, the unit tests and the API
documentation. If there were no errors, then everything can be
installed on the system. As superuser, execute:
\begin{verbatim}
make install
\end{verbatim}

If you consider extending the library, you will probably want to
execute the unit tests. These are in the ``tests/'' folder. They can
be built as usual:
\begin{verbatim}
cd tests
make
\end{verbatim}

To run the tests, simply execute:
\begin{verbatim}
./test
\end{verbatim}

If all tests have run succesfully, the output will look like this:
\begin{verbatim}
Running 213 test cases...

*** No errors detected
\end{verbatim}

By default, tests are built with the ``--coverage'' flag, which create
instrumented versions of the binary files that generate .gcno and
.gcda files. These files contain statistics about the proportion of
the code that has been executed during the tests. They can be fed to
Gcov directly:
\begin{verbatim}
gcov -n main.cpp -f | c++filt
gcov -o ../armv7 -n function-dbg.gcno -f | c++filt
\end{verbatim}

A formatted view of the coverage data can be generated by a simple
Perl script in the ``tests'' directory:
\begin{verbatim}
./cov.pl
\end{verbatim}


\section{Library architecture}
\label{sec:arch}

% - Based on ARM Architecture Reference Manual
% - Pseudo-functions
Libarmisa is mostly a library of functions that implement the behavior
of ARM instructions. However, to make a full instruction set
simulator, instruction behavior is not enough: the processor has to
maintain a state. That state affects and is affected by the execution
of instructions. Therefore, it is necessary to give the instructions
access to a shared state structure that contains registers, memory,
etc.

While it would be quite reasonable to include such structures in the
library, they would typically be redundant with the client
application's own data structures. Moreover, a synchronization step
between client state and library state would be required before and
after the execution of each instruction. This problem is solved with
the use of function templates.

In Libarmisa, all behavior functions are actually function
templates. Their only template argument is the processor type. It can
be any structure or reference to a structure that contains the
following fields:
\begin{itemize}
\item CPSR, current program status register
\item PC, program counter
\item R, register bank
\item iMem, instruction memory
\item dMem, data memory
\end{itemize}

The CPSR must have the exact same fields as specified by the ARM
documentation and they must all be the same type. The register bank
must implement the \verb=[]= operator and contain at least 16
values. Memories must implement the following functions:
\begin{itemize}
\item \verb=read_dword()=
\item \verb=read_word()=
\item \verb=read_half()=
\item \verb=read_byte()=
\item \verb=write_dword()=
\item \verb=write_word()=
\item \verb=write_half()=
\item \verb=write_byte()=
\end{itemize}

Processor and CPSR adaptor structures are provided in the
``armv7/processor.hpp'' file. These structure templates can be used to adapt
existing structures to Libarmisa's requirements. They are also a listing
of what the functions espect these structures to contan.

An example of a memory implementation can be found in
``tests/armv7\_test\_proc.hpp''.

Unless otherwise noted, all numeric values included in the processor
structure and its substructures are expected to be convertible to
32-bit unsigned integer.


\section{Using the library}
\label{sec:using}

To use the library within a project, two basic tasks must be
performed: setting up the processor structure and calling behavior
functions that will work with that structure.

As discussed in section \ref{sec:arch}, Libarmisa functions expect
to receive a processor structure as an argument. The actual setup
process depends on your application's own structures. For testing
purposes, the following types are used:
\begin{verbatim}
typedef uint32_t  test_field;
typedef uint32_t  test_reg;
typedef uint32_t* test_bank;
typedef arm::cpsr_adaptor< test_field > test_cpsr;
typedef arm::armv7_core  < test_cpsr, test_reg,
                           test_bank, test_mem<1024> > test_proc;
\end{verbatim}

In this example, all integer values are uint32\_t. Memories use the
``test\_mem'' memory type:
\begin{verbatim}
template< uint32_t mem_size >
struct test_mem
{
    union
    {
        uint64_t dwords[mem_size/8];
        uint32_t words [mem_size/4];
        uint16_t halves[mem_size/2];
        uint8_t  bytes [mem_size];
    };

    uint64_t read_dword( uint32_t a ) const { return dwords[a/8]; }
    uint32_t read_word ( uint32_t a ) const { return  words[a/4]; }
    uint16_t read_half ( uint32_t a ) const { return halves[a/2]; }
    uint8_t  read_byte ( uint32_t a ) const { return  bytes[a];   }

    void write_dword( uint32_t a, uint64_t d ) { dwords[a/8] = d; }
    void write_word ( uint32_t a, uint32_t d ) {  words[a/4] = d; }
    void write_half ( uint32_t a, uint16_t d ) { halves[a/2] = d; }
    void write_byte ( uint32_t a,  uint8_t d ) {  bytes[a]   = d; }
};
\end{verbatim}

Once the types have been defined, an actual test processor instance
can be created:
\begin{verbatim}
test_cpsr CPSR;
uint32_t  R[16];
memset( &CPSR, 0, sizeof( CPSR ) );
memset(     R, 0, sizeof( uint32_t ) * 16 );
test_proc proc = { CPSR, 0, R, {}, {} };
\end{verbatim}

The ``proc'' structure can then be passed to library functions, along
with an instruction word. In the following example, a simple
register-register subtraction is performed:
\begin{verbatim}
proc.R[0] = 7;
proc.R[2] = 5;
arm::SUB_reg_A1( proc, 0xF0401002 );
// proc.R[1] == 2
\end{verbatim}

The first argument to the function is the processor structure, as was
just defined. The second argument is the 32-bit instruction
itself. Its meaning varies depending on the instruction and its
encoding.

\section{Missing features}
\label{sec:features}

Libarmisa implements the basic ARMv7 instruction set. However, some
features are still missing.

Here is a short list of features that could be added to the library:
\begin{description}
\item[Memory management]
\item[Debugging support]
\item[Synchronization primitives]
\item[Coprocessor support]
\item[Thumb encodings]
\item[ThumbEE]
\item[Jazelle]
\item[VFP]
\item[SIMD]
\item[TrustZone]
\end{description}

% TODO: more details


%\section{Building an ARM toolchain}
%\label{sec:toolchain}
%TODO


\newpage
\bibliographystyle{ieeetr}
\bibliography{refs}

\end{document}
